# 二叉查找树

## Remove

1. 假设待删除节点为 A，找到 A 节点的左邻居或者右邻居，左邻居或右邻居可能为空

把二叉查找树按照中序遍历打印出来，将得到一个排序数组，所谓左邻居，是指该数组中左边紧邻要删除节点
的元素，而右邻居是指数组中右边紧邻要删除节点的元素。如下面一棵树中:

```
        ┌── 13
    ┌── 12
┌── 11
|   └── 10
|       └── 9
8       ┌── 7
│   ┌── 6
|   |   └── 5
└── 4
    │   ┌── 3
    └── 2
        └── 1
```

中序遍历结果: 1 2 3 4 5 6 7 8 9 10 11 12 13
那么节点 8 的左邻居是 7，右邻居是 9；
节点 11 的左邻居是 10，右邻居是 12。
可见一个节点的左邻居或是有邻居一定是位于叶子节点上的，而且满足:
左邻居在左子树的最右侧叶子节点上，右邻居在右子树的最左侧叶子节点上。

故左邻居或是右邻居的查找方法特别简单:

```
func (t *Tree) leftNeighbor(node *Node) *Node {
	neighbor := node.Left
	for neighbor != nil && neighbor.Right != nil {
		neighbor = neighbor.Right
	}
	return neighbor
}
```

```
func (t *Tree) rightNeighbor(node *Node) *Node {
	neighbor := node.Right
	for neighbor != nil && neighbor.Left != nil {
		neighbor = neighbor.Left
	}
	return neighbor
}
```

2. 找到邻居即是找到了候选者，称为 C，用于填补删除 A 节点留下来的空缺
3. 摘除邻居节点
4. 删除 A 节点
5. 将邻居节点 C 放置在 A 节点留下的空位上，设置好前后关联的指针

该方法对任意 A 节点都有效，包括叶子节点和根节点。


## 边界条件

1. 根节点为空
2. 左右子树为空


# 根据前序遍历结果与中序遍历结果逆向构造二叉树

比如如下用例:

pre order: a b d h e c f g

in  order: h d b e a f c g

采用分治思想，从底向上逐步构造，具体而言:

1. 根据前序遍历结果，知道第一个元素 a 就是树的根节点，然后再到中序遍历结果中找到该根结点 a
2. 在中序遍历结果中，a 左边的序列是左子树遍历结果，a 右边的序列是右子树的遍历结果，那么就可以以 a 将中序结果进行二分，h d b e / a / f c g
3. 在前序遍历结果中，实际上也可以将结果进行二分，分为 root / left / right，只是我们只知道 root 元素，不知道 left 和 right 各自的长度，不知道怎么区分开来
4. 我们知道，一棵树，节点数量是确定的，不论怎么遍历，它的输出长度是固定的。现在我们根据中序遍历结果，知道了左子树的长度和右子树的长度，那么我们就可以将前序遍历的结果进行二分，a / b d h e / c f g
5. 通过二分，我们得到了左子树的前序遍历结果和中序遍历结果，分别为 b d h e 和 h d b e；也知道了右子树的前序遍历结果和中序遍历结果，分别为 c f g 和 f c g
6. 后面左子树和右子树分别递归执行本流程
7. 递归返回，我们应该得到左子树的根节点和右子树的根结点，同时我们也知道当前的根节点，所以可以组合为一棵树并返回

代码实现见 calcPostOrder

如果元素有重复，那么可能会有多种解，情况不唯一，如下面两棵树，它们有着一样的前序和中序序列:
```
┌── a
a
|   ┌── d
└── b
    └── c

a       ┌── a
|   ┌── d
└── b
    └── c
```

pre order: a b c d a 
in  order: c b d a a
